#!/usr/bin/env node
import { access as f, mkdir as S, writeFile as C } from "node:fs/promises";
import { constants as y } from "node:fs";
import { join as d } from "node:path";
async function g(o) {
  let s = process.cwd(), r = d(s, "src");
  try {
    await f(r, y.F_OK);
  } catch {
    throw new Error('Error: "src" folder does not exist.');
  }
  let h = d(r, "lib"), e = d(r, "libs"), t;
  try {
    await f(h, y.F_OK), t = h;
  } catch {
    try {
      await f(e, y.F_OK), t = e;
    } catch {
      await S(e, { recursive: !0 }),
        console.log("Created ./src/libs folder"),
        t = e;
    }
  }
  let i = d(t, `hot-shot.${o === "ts" ? "ts" : "js"}`);
  try {
    await f(i, y.F_OK), console.log("Required file already exists.");
  } catch {
    await C(i, "// hot-shot file"),
      console.log(`Created hot-shot.${o === "ts" ? "ts" : "js"} in ${t}`);
  }
}
import { parseArgs as D } from "node:util";
import n from "fs";
import c from "path";
async function $(o) {
  console.log("**Step 1: Checking Project Type...**");
  let s = await x();
  if (
    console.log(`Project Type: ${s}`),
      console.log("**Step 2: Checking for 'src' Directory...**"),
      !await p()
  ) console.error("Error: 'src' directory not found."), process.exit(1);
  console.log("Found 'src' directory."),
    console.log("**Step 3: Checking/Creating 'mods' Directory...**");
  let h = c.join(process.cwd(), "src", "mods");
  await b(h), console.log("'mods' directory is available.");
  let e = `${o}-mod`, t = c.join(h, e);
  n.mkdirSync(t, { recursive: !0 });
  let i = s === "ts" ? ".ts" : ".js";
  [{ name: `${o}.routes`, path: c.join(t, `${o}.routes${i}`) }, {
    name: `${o}.controller`,
    path: c.join(t, `${o}.controller${i}`),
  }, { name: `${o}.services`, path: c.join(t, `${o}.services${i}`) }].forEach(
    (w) => {
      n.writeFileSync(w.path, `// ${w.name}${i} - Generated by HotShot`),
        console.log(`Created: ${c.relative(process.cwd(), w.path)}`);
    },
  );
}
async function x() {
  let o = c.join(process.cwd(), "hotshot.config.js");
  if (console.log(o), !n.existsSync(o)) {
    throw new Error("hotshot.config.js not found.");
  }
  return (await import(o)).HotshotConf.projectType;
}
async function p() {
  return n.existsSync(c.join(process.cwd(), "src"));
}
async function b(o) {
  if (!n.existsSync(o)) {
    n.mkdirSync(o, { recursive: !0 }),
      console.log(`Created 'ods' directory at: ${o}`);
  }
}
var { values: j, positionals: l } = D({
    args: process.argv.slice(2),
    options: { js: { type: "boolean" }, ts: { type: "boolean" } },
    allowPositionals: !0,
  }),
  a;
if (j.ts) a = "ts";
else if (j.js) a = "js";
else if (l[0] !== "g" && l[0] !== "reload") {
  console.error(
    "Error: Please specify either --js or --ts for non-'g' commands.",
  ), process.exit(1);
}
var P = l[0];
switch (P) {
  case "reload":
    if (!a) {
      console.error(
        "Error: Please specify either --js or --ts for 'eload' command.",
      ), process.exit(1);
    }
    console.log(`Reloading with project type: ${a}...`),
      g(a).then(() => console.log("Reload complete.")).catch((r) => {
        console.error("Error during reload:", r);
      });
    break;
  case "g":
    let o = l[1], s = l.slice(2);
    switch (o) {
      case "mod":
        if (s.length === 0) {
          console.error(
            "Error: Please specify a module name for 'g mod' command.",
          ), process.exit(1);
        }
        let r = s[0];
        console.log(`Module name for generation: ${r}`), await $(r);
        break;
      default:
        console.log(
          `Unknown generate command: ${o}. Usage: hotshot g mod <module_name>`,
        );
        break;
    }
    break;
  default:
    console.log(`Unknown command: ${P}. Usage: 
            hotshot reload --js or --ts
            hotshot g mod <module_name>`);
    break;
}
